-- | The attribute grammar used for converting a 'BibtexEntry' to 'Html'.
--  
--   The bibtex field specification is constructed as a tree, and then a tree
--   fold/walk is performed using the given field names/values as input. The output
--   is the generated html and warning/error messages. All error/warning messages
--   are collected even if an error is encountered. Html output is only produced,
--   if there were no errors.
--   
-- * Implementation remarks
--   
--   (The term attribute in this text is referring to the attribute grammar,
--    the term field is used to refer to fields of a bibtex entry.)
--
--   It is assumed that the printing of any field is indepent from all
--   other fields. To print an entry, it is therefore sufficient
--   to sort the fields in the correct order and call `fieldToHtml`
--   for each field. 
--   This is achieved using a tree specifying allowed fields, their 
--   combinations and their order. Then a fold
--   over this tree takes place, carrying the field values as attribute
--   throughout the tree. Each node of the tree then decides how to print a
--   subset of this fields.
--
--   For sorting alone the tree might not be strictly necessary,
--   but Bibtex is more complicated as it sometimes allows
--   a mutually-exclusive choice between two fields and a variety
--   of optional fields. As it is also a good idea to validate that
--   a valid set of field values is given, a simple list sorter
--   does not suffice.
--
-- * Usage remarks
--   
--   The function `entryToHtml` is intended as sole entry point for
--   users of this module.
--   (TODO: do not export all the other definitions. How to do this in uuagc?)

imports
{
import Html.Tree
import CCO.Feedback
import CCO.Printing
import Bibtex
import Data.Map hiding (map)
import qualified Data.Map as M
}

-- | A specification tree for the possible fields and combinations thereof in a bibtex entry.
data SpecTree
    | Both left :: SpecTree right :: SpecTree
    | Either left :: SpecTree right :: SpecTree
    | Optional child :: SpecTree
    | Exactly field  :: Field

deriving SpecTree : Show

attr SpecTree
    syn avail use {&&} {True} :: Bool
    syn html use {++} {[]} :: { [HtmlTree] }
    syn msgs use {++} {[]} :: { [Message] }
    syn reqStr use {++} {""} :: String
    inh etype :: Type
    inh fields :: {Map Field String}
    inh key :: String

sem SpecTree
    | Either lhs.avail = { @left.avail || @right.avail }
             lhs.msgs = { case (@left.avail, @right.avail) of
                            (True, True)   -> [Warning 1 (text $ "Both " ++ @left.reqStr ++ " and " ++ @right.reqStr ++ " are given, but are mutually exclusive in entry " ++ @lhs.key ++ ".")]
                            (False, False) -> [Error (text $ "Neither of " ++ @left.reqStr ++ " and " ++ @right.reqStr ++ " is given, but one of them is required in entry " ++ @lhs.key ++ ".")]
                            _              -> []}
             lhs.html = { case (@left.avail, @right.avail) of
                            (True, _)      -> @left.html
                            (False, True)  -> @right.html }
             lhs.reqStr = { "(" ++ @left.reqStr ++ " or " ++ @right.reqStr ++ ")"}
    | Optional lhs.msgs = { if @child.avail then @child.msgs else [] }
               lhs.html = { if @child.avail then @child.html else [] }
               lhs.avail = True
               lhs.reqStr = ""
    | Exactly lhs.avail = { @field `member` @lhs.fields }
              lhs.msgs = { if not (@field `member` @lhs.fields) then [Error (text $ "Required field " ++ (show @field) ++ " is missing in entry " ++ @lhs.key ++ ".")] else []}
              lhs.html = { [fieldToHtml @lhs.etype (@field, @lhs.fields ! @field)] }
              lhs.reqStr = { show @field }
    | Both lhs.reqStr = { "(" ++ @left.reqStr ++ " and " ++ @right.reqStr ++ ")" }

{

-- | Expects at least one of the given specifications to hold,
--   and uses all holding specifications when pretty printing.
someOf :: SpecTree -> SpecTree -> SpecTree
someOf s1 s2 = Either (Both s1 (Optional s2)) s2

-- | Combines all given specification trees using `Both`. Undefined for empty lists.
allOf :: [SpecTree] -> SpecTree
allOf [s] = s
allOf ss = foldr1 (Both) ss

-- local abbrevations
e = Exactly
o = Optional . Exactly
either1 f1 f2 = Either (Exactly f1) (Exactly f2)
sAE = either1 Author Editor

-- | Returns the specification tree for a given entry type. All entry types specified
--   in http://www.andy-roberts.net/res/writing/latex/bibentries.pdf are implemented as of 24.11.2013.
--   The order of the fields indicates the order in which they are to be printed. 
--   REMARK: Please note that the order is incorrect for many entry types, as this information
--   is hard to get by. To rectify the wrong ordering, the fields can just be moved to the proper location below.
spec :: Type -> SpecTree
spec Article    = allOf [sAE, e Title, e Journal, e Year, o Volume, o Number, o Pages, o Month, o Note]
spec Book       = allOf [sAE, e Title, e Publisher, e Year, Optional (either1 Volume Number), o Series, o Address, o Edition, o Month, o Note]
spec Booklet    = allOf [e Title, o Author, o HowPublished, o Address, o Month, o Year, o Note]
spec Conference = spec Inproceedings
spec Inbook     = allOf [sAE, e Title, someOf (e Chapter) (e Pages), e Publisher, e Year, o Volume, Optional (either1 Volume Number), o Series, o Type, o Address, o Edition, o Month, o Note]
spec Incollection  = allOf [e Author, e Title, e Booktitle, e Year, o Editor, Optional (either1 Volume Number), o Series, o Pages, o Address, o Month, o Organization, o Publisher, o Note]
spec Inproceedings = allOf [e Author, e Title, o Editor, e Booktitle, e Year, Optional (either1 Volume Number), o Series, o Pages, o Address, o Month, o Organization, o Publisher, o Note]
spec Manual     = allOf [e Title, o Author, o Organization, o Address, o Edition, o Month, o Year, o Note]
spec Mastersthesis = allOf [e Author, e Title, e School, e Year, o Type, o Address, o Month, o Note]
spec Misc       = allOf [o Author, o Title, o HowPublished, o Month, o Year, o Note]
spec Phdthesis  = allOf [e Author, e Title, e School, e Year, o Type, o Address, o Month, o Note]
spec Proceedings = allOf [e Title, e Year, o Editor, Optional (either1 Volume Number), o Series, o Address, o Month, o Organization, o Publisher, o Note]
spec Techreport = allOf [e Author, e Title, e Institution, e Year, o Type, o Address, o Month, o Note]
spec Unpublished = allOf [e Author, e Title, e Note, o Month, o Year]



-- | Converts an attribute to a html tree.
fieldToHtml :: Type -> (Field, String) -> HtmlTree
fieldToHtml Inproceedings (Title, s) = Text s
fieldToHtml Inproceedings (Booktitle, s) = Elem "em" [] [Text s]
fieldToHtml _ (Title, s) = Elem "em" [] [Text s]
fieldToHtml _ (Editor, s) = Text $ "In: " ++ s
fieldToHtml _ (f, s) = Text s


-- | Derives the key shown to the user when referring to an entry, eg "[LO98]".
deriveDispKey :: BibtexEntry -> String
--TODO derive key correctly
deriveDispKey (Entry t k fs) = k


-- | Checks whether the given tree holds on a bitex entry.
isAvail :: BibtexEntry -> SpecTree -> Bool
isAvail t s = avail_Syn_SpecTree $ walkTree t s 

-- | Converts a bibtex entry to html. If the first element of the result contains
--   no error messages, the second element is a html tree. If there are error
--   messages, `Nothing` will be returned as second element.
entryToHtml :: BibtexEntry -> ([Message], Maybe (HtmlTree, HtmlTree))
entryToHtml e@(Entry t _ _) = entryToHtml1 (spec t) e

entryToHtml1 :: SpecTree -> BibtexEntry -> ([Message], Maybe (HtmlTree, HtmlTree))
entryToHtml1 s e@(Entry _ k _) = if avail_Syn_SpecTree res then (msgs, Just (htmlInd, htmlEnt)) else (msgs, Nothing)
    where
        res = walkTree e s
        msgs = msgs_Syn_SpecTree res

        isError (Error _) = True
        isError _ = False

        htmlInd = Elem "a" [("href", k)] [dKey]
        htmlEnt = Elem "tr" [("valign", "top")] [
                            Elem "td" [] [Elem "a" [("name", k)] [dKey]],
                            Elem "td" [] (html_Syn_SpecTree res)]
        dKey = Text $ "[" ++ (deriveDispKey e) ++ "]"

walkTree :: BibtexEntry -> SpecTree -> Syn_SpecTree
walkTree (Entry t k fs) s = wrap_SpecTree (sem_SpecTree s) inh
    where inh = Inh_SpecTree { etype_Inh_SpecTree = t, fields_Inh_SpecTree = M.fromList fs, key_Inh_SpecTree = k }

}


