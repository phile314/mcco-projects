-- | The attribute grammar used for converting a 'BibtexDb' in 'Html'.

imports
{
import Html.Tree
import CCO.Feedback
import CCO.Printing
import Bibtex.Basic
import Data.Map
import qualified Data.Map as M
}


data SpecNode
    | Both left :: SpecNode right :: SpecNode
    | Either left :: Field right :: Field
    | Optional field :: Field
    | Exactly field  :: Field


attr SpecNode
    syn html use {++} {[]} :: { [HtmlTree] }
    syn msgs use {++} {[]} :: { [Message] }
    inh etype :: Type
    inh fields :: {Map Field String}
    inh key :: String

sem SpecNode
    | Either lhs.msgs = { case member' @lhs.fields @left @right of
                            (True, True)   -> [Warning 1 (text $ "Both " ++ (show @left) ++ " and " ++ (show @right) ++ " are given, but are mutually exclusive in entry " ++ @lhs.key ++ ".")]
                            (False, False) -> [Error (text $ "Neither of " ++ (show @left) ++ " and " ++ (show @right) ++ " is given, but one of them is required in entry " ++ @lhs.key ++ ".")]
                            _              -> []}
             lhs.html = { case member' @lhs.fields @left @right of
                            (True, _)      -> fieldToHtml @lhs.etype (@left, @lhs.fields ! @left)
                            (False, True)  -> fieldToHtml @lhs.etype (@right, @lhs.fields ! @right)}
    | Optional lhs.html = { case @field `M.lookup` @lhs.fields of
                            (Just v) -> fieldToHtml @lhs.etype (@field, v)
                            Nothing  -> [] }
    | Exactly lhs.msgs = { if not (@field `member` @lhs.fields) then [Error (text $ "Required field " ++ (show @field) ++ " is missing in entry " ++ @lhs.key ++ ".")] else []}
              lhs.html = { fieldToHtml @lhs.etype (@field, @lhs.fields ! @field) }

{


member' :: Map Field String -> Field -> Field -> (Bool, Bool)
member' m f1 f2 = (f1 `member` m, f2 `member` m)

fieldToHtml :: Type -> (Field, String) -> [HtmlTree]
fieldToHtml _ (f, s) = [Text s]

allOf :: [SpecNode] -> SpecNode
allOf ss = foldr1 (Both) ss

e = Exactly
o = Optional

sAE = Either Author Editor

spec :: Type -> SpecNode
spec Article = allOf [sAE, e Title, e Journal, e Year, o Volume, o Number, o Pages, o Month, o Note]

fieldsToHtml :: String -> Type -> [(Field, String)] -> ([Message], Maybe [HtmlTree])
fieldsToHtml k t fs = if any isError msgs then (msgs, Nothing) else (msgs, Just $ html_Syn_SpecNode res)
    where 
        inh = Inh_SpecNode { etype_Inh_SpecNode = t, fields_Inh_SpecNode = M.fromList fs, key_Inh_SpecNode = k }
        res = wrap_SpecNode (sem_SpecNode (spec t)) inh
        msgs = msgs_Syn_SpecNode res
        isError (Error _) = True
        isError _ = False
    

}


