-- | Attribute grammar for type checking t-diagrams

module {Type.AG}{}{
import Type.Internal
import CCO.Diag (Diag(..), Diag_(..))
}

include "../CCO/Diag/AG.ag"

-- | Makes available the position in order for error messages.
attr Diag_ inh pos :: {SourcePos}
attr Diag syn pos :: {SourcePos}

sem Diag
  | Diag d.pos = @pos
         lhs.pos = @pos

-- | The type of a t-diagram.
-- The type returned is correct only if no error massage is raised.
attr Diag_ Diag
  syn ty :: {Type}

sem Diag_
  | Program  lhs.ty = ProgramT @l UnitT
  | Platform lhs.ty = PlatformT @m
  | Interpreter lhs.ty = ProgramT @m (InterpreterT @l)
  | Compiler lhs.ty = ProgramT @m (CompilerT @l1 @l2)
  | Execute lhs.ty = result @d1.ty
  | Compile lhs.ty = ProgramT ((to . result) @d2.ty) (result @d1.ty)

{
-- | @'matchLanguage' d1 d2@ is true if @d1@ is a 'ProgramT' implemented 
-- in some language, which is the accepted language of the 'InterpreterT' 
-- or 'PlatformT' @d2@, false otherwise. Coercion of 'InterpreterT' to 
-- platform takes place here.
matchLanguage :: Type -> Type -> Bool
matchLanguage (ProgramT l _) (PlatformT l') = l == l'
matchLanguage (ProgramT l _) (InterpreterT l') = l == l'
matchLanguage _ _ = False

-- | @'matchCompiler' d1 d2@ is true if @d1@ is a 'ProgramT' 
-- implemented in some language, which is the input language
-- of the 'CompilerT' @d2@.
matchCompiler :: Type -> Type -> Bool
matchCompiler (ProgramT l _) (CompilerT l1 _) = l == l1
matchCompiler _ _ = False
}
