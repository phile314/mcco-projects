-- | Attribute grammar for type checking t-diagrams

module {Type.AG}{}{
import Type.Internal
import Type.Error
import Control.Monad ((>>))
import CCO.Diag (Diag(..), Diag_(..))
import CCO.Feedback (Message(..), messages, Feedback)
import CCO.Printing 
}

include "../CCO/Diag/AG.ag"

{
-- | Typechecks the given 'Diag', if it is well-typed it is returned,
-- otherwise the 'Feedback' monad fails with some type error.
typeCheck :: Diag -> Feedback Diag
typeCheck d = messages msgs >> return d
  where msgs = msgs_Syn_Diag $ wrap_Diag (sem_Diag d) (Inh_Diag {})
}

-- | Makes available the position for the error messages.
attr Diag_ inh pos :: {SourcePos}
attr Diag syn pos :: {SourcePos}

sem Diag
  | Diag d.pos = @pos
         lhs.pos = @pos

attr Diag_ Diag
  syn ty :: {Type} -- ^ The type returned is 'ErrorT' if a t-diagram is ill-typed.
  syn msgs use {++} {[]} :: {[Message]}  -- ^ Error messages (they are produced in depth-first order)

sem Diag_
  | Program  lhs.ty = ProgramT @l UnitT
  | Platform lhs.ty = PlatformT @m
  | Interpreter lhs.ty = ProgramT @m (PlatformT @l)
  | Compiler lhs.ty = ProgramT @m (CompilerT @l1 @l2)
  | Execute loc .executeRes = execute @d1.ty @d2.ty
            lhs.ty = onTypeError @loc.executeRes
            lhs.msgs = @d1.msgs ++ @d2.msgs ++ errorOf @lhs.pos @loc.executeRes
  | Compile loc .compileRes = compile @d1.ty @d2.ty
            lhs.ty = onTypeError @loc.compileRes
            lhs.msgs = @d1.msgs ++ @d2.msgs ++ errorOf @lhs.pos @loc.compileRes

{
-- | If a type error has been raised returns 'ErrorT', the original type otherwise.
onTypeError :: Either TypeError Type -> Type
onTypeError = either (const ErrorT) id

-- | @'errorOf' p t@ produces an error message at position @p@ if @t@ is 'TypeError'.
-- Otherwise returns an empty list. 
errorOf :: SourcePos -> Either TypeError Type -> [Message]
errorOf p = either errorMessage (const [])
  where errorMessage e = [Error (pp p >-< pp e) ] 

-- | @'execute' d1 d2@ succeds if @d1@ is a 'ProgramT' implemented 
-- in some language, which is the accepted language of 'PlatformT' @d2@, 
-- fails otherwise. Coercion of 'Interpreter' (type @'ProgramT' ('PlatformT')@) to 
-- @'PlatformT'@ takes place here.
execute :: Type -> Type -> Either TypeError Type
execute (ProgramT l r) (PlatformT l') | l == l' = Right r
execute (ProgramT l r) (ProgramT m (PlatformT l')) | l == l' = Right $ ProgramT m r
execute (ProgramT _ _) ErrorT = Right ErrorT
execute ErrorT _ = Right ErrorT
execute t1 t2 = Left $ executeError t1 t2

-- | @'compile' d1 d2@ succeds if @d1@ is a 'ProgramT' 
-- implemented in some language, which is the input language
-- of the 'CompilerT' @d2@, fails otherwise.
compile :: Type -> Type -> Either TypeError Type
compile (ProgramT l r) (ProgramT m (CompilerT l1 l2)) | l == l1 = Right $ ProgramT l2 r
compile (ProgramT _ _) ErrorT = Right ErrorT
compile ErrorT _ = Right ErrorT
compile t1 t2 = Left $ compileError t1 t2
}
