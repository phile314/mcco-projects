-- | Attribute grammar for type checking t-diagrams

module {Type.AG}{}{
import Type.Internal
import CCO.Diag (Diag(..), Diag_(..))
}

include "../CCO/Diag/AG.ag"

-- | Makes available the position in order for error messages.
attr Diag_ inh pos :: {SourcePos}
attr Diag syn pos :: {SourcePos}

sem Diag
  | Diag d.pos = @pos
         lhs.pos = @pos

-- | The type of a t-diagram.
-- The type returned is correct only if no error massage is raised.
attr Diag_ Diag
  syn ty :: {Type}

sem Diag_
  | Program  lhs.ty = ProgramT @l UnitT
  | Platform lhs.ty = PlatformT @m
  | Interpreter lhs.ty = ProgramT @m (InterpreterT @l)
  | Compiler lhs.ty = ProgramT @m (CompilerT @l1 @l2)
  | Execute lhs.ty = onTypeError (execute @d1.ty @d2.ty)
  | Compile lhs.ty = onTypeError (compile @d1.ty @d2.ty)

{

-- Temporary definition
data TypeError = TypeError

-- | If a type error has been raised returns 'ErrorT', the original type otherwise.
onTypeError :: Either TypeError Type -> Type
onTypeError = either (const ErrorT) id

-- | @'execute' d1 d2@ succeds if @d1@ is a 'ProgramT' implemented 
-- in some language, which is the accepted language of the 'InterpreterT' 
-- or 'PlatformT' @d2@, fails otherwise. Coercion of 'InterpreterT' to 
-- platform takes place here.
execute :: Type -> Type -> Either TypeError Type
execute (ProgramT l r) (PlatformT l') | l == l' = Right r
execute (ProgramT l r) (ProgramT m (InterpreterT l')) | l == l' = Right $ ProgramT m r
execute d1 d2 = (error . unwords . (map show)) [d1, d2]     -- TODO Produce correct type error

-- | @'compile' d1 d2@ succeds if @d1@ is a 'ProgramT' 
-- implemented in some language, which is the input language
-- of the 'CompilerT' @d2@, fails otherwise.
compile :: Type -> Type -> Either TypeError Type
compile (ProgramT l r) (ProgramT m (CompilerT l1 l2)) | l == l1 = Right $ ProgramT l2 r
compile d1 d2 = (error . unwords . (map show)) [d1, d2] -- TODO Produce correct type error
}
