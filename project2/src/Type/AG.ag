-- | Attribute grammar for type checking t-diagrams

module {Type.AG}{}{
import Data.Maybe (catMaybes, fromJust)
import Type.Internal
import Type.Error
import Control.Monad ((>>))
import CCO.Diag (Diag(..), Diag_(..), DeclS, Decl)
import CCO.Feedback (Message(..), messages, Feedback)
import CCO.Printing hiding (empty) 
import Data.Map (insert, empty, Map)
import qualified Data.Map as M
}

include "../CCO/Diag/AG.ag"

{
-- | Typechecks the given 'Diag', if it is well-typed it is returned,
-- otherwise the 'Feedback' monad fails with some type error.
typeCheck :: Diag -> Feedback Diag
typeCheck d = messages msgs >> return d
  where msgs = msgs_Syn_Diag $ wrap_Diag (sem_Diag d) (Inh_Diag {env_Inh_Diag = empty})
}

-- | Makes available the position for the error messages.
attr Diag_ inh pos :: {SourcePos}
attr Diag syn pos :: {SourcePos}

sem Diag
  | Diag d.pos = @pos
         lhs.pos = @pos

attr Diag_ Diag
  syn ty :: {Type} -- ^ The type returned is 'ErrorT' if a t-diagram is ill-typed. 

attr Diag_ Diag DeclS Decl
  syn msgs use {++} {[]} :: {[Message]}  -- ^ Error messages (they are produced in depth-first order)
  chn env :: {Map String Type}  -- ^ Contains the var identifier-type bindings

sem Diag_
  | Program  lhs.ty = ProgramT @l UnitT
  | Platform lhs.ty = PlatformT @m
  | Interpreter lhs.ty = ProgramT @m (PlatformT @l)
  | Compiler lhs.ty = ProgramT @m (CompilerT @l1 @l2)
  | Execute 
    loc .executeError = 
      catMaybes [matchProgram @d1.ty, matchPlatform @d2.ty, matchLanguage @d1.ty @d2.ty]
    lhs.ty = case (@loc.executeError, @d2.ty) of
                  ([], PlatformT _) -> result @d1.ty
                  ([], _)           -> ProgramT (language @d2.ty) (result @d1.ty)
                  (_ , _)           -> ErrorT 
    lhs.msgs = @d1.msgs ++ @d2.msgs ++ map (errorMessage @lhs.pos) @loc.executeError
  | Compile 
    loc .compileError = 
      catMaybes [matchProgram @d1.ty, matchCompiler @d2.ty, matchLanguage @d1.ty @d2.ty]
    lhs.ty = case @loc.compileError of
                  [] -> ProgramT ((to . result) @d2.ty) (result @d1.ty)
                  _ -> ErrorT 
    lhs.msgs = @d1.msgs ++ @d2.msgs ++ map (errorMessage @lhs.pos) @loc.compileError
  | Let lhs.ty = @in.ty
        lhs.env = @lhs.env
  | VarAccess 
      loc .diagBound = M.lookup @v @lhs.env
      lhs.ty = case @loc.diagBound of
                 Just d -> d
                 Nothing -> ErrorT
      lhs.msgs = case @loc.diagBound of
                  Just d -> []    -- If any they have already been generated when declared
                  Nothing -> [errorMessage @lhs.pos (UndefinedVariable @v)]

sem Decl
  | Tuple lhs.env = insert @x1 @x2.ty @lhs.env      -- TODO Check whether there is redefinition
          lhs.msgs = @x2.msgs
{
-- | @'matchProgram' t@ returns a 'TypeError' if @t@ is not a 'ProgramT'.
-- 'ErrorT' does not yield a 'TypeError'.
matchProgram :: Type -> Maybe TypeError
matchProgram (ProgramT _ _) = Nothing
matchProgram ErrorT = Nothing
matchProgram t = Just $ ProgramError t

-- | @'matchPlatform' t@ returns a 'TypeError' if @t@ is not a 'PlatformT' or an interpreter
-- (@'ProgramT' ('PlatformT')@).
-- 'ErrorT' does not yield a 'TypeError'.
matchPlatform :: Type -> Maybe TypeError
matchPlatform (PlatformT _) = Nothing
matchPlatform (ProgramT _ (PlatformT _)) = Nothing
matchPlatform ErrorT = Nothing
matchPlatform t = Just $ PlatformError t

-- | @'matchLang' t1 t2@ returns a 'TypeError' if the two given types can be properly combined through
-- 'Compile' or 'Execute' but their languages do not match, 'Nothing' otherwise.
matchLanguage p1@(ProgramT l r) p2@(PlatformT l') | l /= l' = Just $ LangError p1 p2
matchLanguage p1@(ProgramT l r) p2@(ProgramT m (PlatformT l')) | l /= l' = Just $ LangError p1 p2
matchLanguage p1@(ProgramT l r) p2@(ProgramT m (CompilerT l1 l2)) | l /= l1 = Just $ LangError p1 p2
matchLanguage _ _ = Nothing

matchCompiler (ProgramT _ (CompilerT _ _)) = Nothing
matchCompiler ErrorT = Nothing
matchCompiler t = Just $ CompilerError t

-- | @'errorMessage' p e@ produces an error message at position @p@ for the 'Printable' datatype @e@.
errorMessage :: (Printable a) => SourcePos -> a -> Message
errorMessage p e = Error (pp p >-< pp e)
}
