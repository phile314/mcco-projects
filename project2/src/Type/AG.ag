-- | Attribute grammar for type checking t-diagrams

module {Type.AG}{}{
import Type.Internal
import CCO.Diag (Diag(..), Diag_(..))
import CCO.Feedback (Message(..))
import CCO.Printing (text)
}

include "../CCO/Diag/AG.ag"

-- | Makes available the position in order for error messages.
attr Diag_ inh pos :: {SourcePos}
attr Diag syn pos :: {SourcePos}

sem Diag
  | Diag d.pos = @pos
         lhs.pos = @pos

attr Diag_ Diag
  syn ty :: {Type} -- ^ The type returned is 'ErrorT' if a t-diagram is ill-typed.
  syn msgs use {++} {[]} :: {[Message]}  -- ^ Error messages
--  syn result :: {Either TypeError Type}  -- ^ The result of the type check

sem Diag_
  | Program  lhs.ty = ProgramT @l UnitT
  | Platform lhs.ty = PlatformT @m
  | Interpreter lhs.ty = ProgramT @m (InterpreterT @l)
  | Compiler lhs.ty = ProgramT @m (CompilerT @l1 @l2)
  | Execute loc .executeRes = execute @d1.ty @d2.ty
            lhs.ty = onTypeError @loc.executeRes
            lhs.msgs = errorOf @lhs.pos @loc.executeRes 
  | Compile loc .compileRes = compile @d1.ty @d2.ty
            lhs.ty = onTypeError @loc.compileRes
            lhs.msgs = errorOf @lhs.pos @loc.compileRes

{

-- | Represent a type error. The first type is the actual given type.
-- The second is a list containing expected types.
data TypeError = TypeError Type [Type]
  deriving (Show, Eq)

-- | If a type error has been raised returns 'ErrorT', the original type otherwise.
onTypeError :: Either TypeError Type -> Type
onTypeError = either (const ErrorT) id

-- | @'errorOf' p t@ produces an error message at position @p@ if @t@ is 'TypeError'.
-- Otherwise returns an empty list. 
errorOf :: SourcePos -> Either TypeError Type -> [Message]
errorOf p = either errorMessage (const [])
  where errorMessage e = [Error $ text (show p ++ show e)] -- TODO add proper description

-- | TODO special cases for handling ErrorT types

-- | @'execute' d1 d2@ succeds if @d1@ is a 'ProgramT' implemented 
-- in some language, which is the accepted language of the 'InterpreterT' 
-- or 'PlatformT' @d2@, fails otherwise. Coercion of 'InterpreterT' to 
-- platform takes place here.
execute :: Type -> Type -> Either TypeError Type
execute (ProgramT l r) (PlatformT l') | l == l' = Right r
execute (ProgramT l r) (ProgramT m (InterpreterT l')) | l == l' = Right $ ProgramT m r
execute (ProgramT l r) t2 = Left $ TypeError t2 [PlatformT l, InterpreterT l]
execute t1 _ = Left $ TypeError t1 [ProgramT "<l>" UnitT]   -- TODO could be anything not only UnitT

-- | @'compile' d1 d2@ succeds if @d1@ is a 'ProgramT' 
-- implemented in some language, which is the input language
-- of the 'CompilerT' @d2@, fails otherwise.
compile :: Type -> Type -> Either TypeError Type
compile (ProgramT l r) (ProgramT m (CompilerT l1 l2)) | l == l1 = Right $ ProgramT l2 r
compile (ProgramT l r) t2 = Left $ TypeError t2 [CompilerT l "<l2>"]
compile t1 _ = Left $ TypeError t1 [ProgramT "<l>" UnitT]   -- TODO could be anything not only UnitT
}
