-- | Attribute grammar for type checking t-diagrams

module {Diag2Picture.Render}{}{
import CCO.Diag (Diag(..), Diag_(..), DeclS, Decl)
import CCO.Picture
import Data.Maybe
import Data.Vec.Base hiding (map)
import Debug.Trace
}

{
type Vec2d = Vec2 Double
type Size = Vec2d

ovlp = 10
}

include "../CCO/Diag/AG.ag"

-- | Makes available the position in order for error messages.
attr Diag_ inh pos :: {SourcePos}
attr Diag syn pos :: {SourcePos}

sem Diag
  | Diag d.pos = @pos
         lhs.pos = @pos

attr Diag_ Diag
  syn pict :: {[Command]}
  syn size :: {Size}
  -- First element is x offset of left lower connection point, second element is distance from left to right connection point OUTDATED.
  syn connStackTop    :: {Maybe Vec2d}
  syn connSide        :: {(Maybe Vec2d, Maybe Vec2d)}
  syn compConnSide    :: {Maybe (Vec2d, Vec2d)}
  syn connStackBottom :: {Maybe Vec2d}

  syn dlng :: String

  syn result :: {String -> Diag}

attr Diag_
  syn result_ use {\a b -> Nothing} {Nothing}:: {Maybe (String -> Diag_)}


sem Diag_
  | Program lhs.result_ = {Just $ \r -> Program @p r}
            lhs.connStackTop    = Nothing
            lhs.connSide        = (Just (7.5:.0:.()), Just (57.5:.0:.()))
            lhs.connStackBottom = Just (7.5:.0:.())
            lhs.size  = (65:.30:.())
            lhs.pict  = mkProg @l @p

  | Platform lhs.connStackTop    = Just (0:.30:.())
             lhs.connSide        = (Nothing, Nothing)
             lhs.connStackBottom = Nothing
             lhs.size  = (50:.30:.())
             lhs.pict  = mkPlat @m

  | Interpreter lhs.result_ = {Just $ \r -> Interpreter @i @l r}
                lhs.connStackTop    = Just (0 :. 30)
                lhs.connSide        = (Just (0 :. 0), Just (50 :. 0))
                lhs.connStackBottom = Just (0 :. 0)
                lhs.size  = (50 :. 30)
                lhs.pict  = mkIntp @m @l @i

  | Compiler lhs.result_ = {Just $ \r -> Compiler @c @l1 @l2 r}
             lhs.dlng  = @l2

             lhs.connStackTop    = Nothing
             lhs.connSide        = (Just (50 :. 0), Just(100 :. 0))
             lhs.compConnSide    = Just (0:.20:.(), 150:.20:.())
             lhs.connStackBottom = Just (50 :. 0)
             lhs.size  = (150 :. 30)
             lhs.pict  = mkCmpl @m @l1 @l2 @c

    | Execute 
            (loc.pos1, loc.pos2) =
                { let (Just c1) = @d1.connStackBottom
                      (Just c2) = @d2.connStackTop
                      p1        = (0:.0)
                      p2        = c1 - c2
                      mins      = minElems [p1, p2]
                  in (p1 - mins, p2 - mins)
                }
            lhs.connStackTop    = translateC @d1.connStackTop @pos1
            lhs.connSide        = (Nothing, Nothing)
            lhs.connStackBottom = translateC @d2.connStackBottom @pos2

            lhs.pict = (translate @d1.pict @pos1) ++ (translate @d2.pict @pos2)

            lhs.size = maxElems [@d1.size + @pos1, @d2.size + @pos2]

  | Compile inst.d3 :: Diag
            inst.d3 = @d1.result @d2.dlng
            lhs.result = @d3.result

            (loc.pos1, loc.pos2, loc.pos3) = 
                { let (_, Just c12)        = @d1.connSide
                      (Just (c21, c22))    = @d2.compConnSide
                      (Just c31, _)        = @d3.connSide
                      p1                   = (0 :. 0)
                      p2                   = c12 - c21
                      p3                   = p2 + c22 - c31
                      mins                 = minElems [p1, p2, p3]
                  in (p1 - mins, p2 - mins, p3 - mins)
                }
                                             

            lhs.connStackTop    = Nothing
            lhs.connSide        = (translateC (fst @d1.connSide) @pos1, translateC (snd @d3.connSide) @pos3)
            lhs.compConnSide    = maybe Nothing (\(a,b) -> Just (a + @pos3, b + @pos3)) @d3.compConnSide
            lhs.connStackBottom = translateC @d2.connStackBottom @pos2

            lhs.pict = (translate @d1.pict @pos1) ++ (translate @d2.pict @pos2) ++ (translate @d3.pict @pos3)

            lhs.size = maxElems [@d1.size + @pos1, @d2.size + @pos2, @d3.size + @pos3]

            
  | VarAccess (lhs.connStackTop, lhs.connSide, lhs.connStackBottom, lhs.size, lhs.pict) = let e = error "Unexpected node VarAccess. Has the Inliner been run?" in (e, e, e, e, e)

sem Diag
  | Diag lhs.result = {maybe @d.result (\a r -> Diag @pos (a r)) @d.result_}

{


extreme :: (a -> a -> a) -> [Vec2 a] -> Vec2 a
extreme f ((a1:.b1:.()):(vs@(_:_))) = (f a1 a2):.(f b1 b2):.()
    where (a2:.b2:.()) = extreme f vs
extreme _ [a] = a

minElems = extreme min
maxElems = extreme max

translateC :: Maybe Vec2d -> Vec2d -> Maybe Vec2d
translateC Nothing _ = Nothing
translateC (Just v) d = Just (v + d)


translate :: [Command] -> Vec2d -> [Command]
translate cs (dx:.dy:.()) = map f cs
  where f (Put (x, y) a) = Put (x + dx, y + dy) a

mkProg :: String -> String -> [Command]
mkProg l n =
    [ Put (7.5, 0)      (Line (1,0)  50)
    , Put (7.5, 0)      (Line (0,1)  15)
    , Put (7.5, 15)     (Line (-1,2) 7.5)
    , Put (57.5, 15)    (Line (1,2)  7.5)
    , Put (57.5, 0)     (Line (0,1)  15)
    , Put (0, 30)       (Line (1,0)  65)
    , Put (7.5, 15)     (Makebox (50, 15) n)
    , Put (7.5, 0)      (Makebox (50, 15) l)]

mkPlat :: String -> [Command]
mkPlat l =
    [ Put (0, 15)       (Line (5,-3)  25)
    , Put (25, 0)       (Line (5,3)   25)
    , Put (0, 15)       (Line (0,1)   15)
    , Put (0, 30)       (Line (1,0)   50)
    , Put (50, 30)      (Line (0,-1)  15)
    , Put (0,15)        (Makebox (50,15) l)]

mkIntp :: String -> String -> String -> [Command]
mkIntp m l n =
    [ Put (0, 0)        (Framebox (50,30) "")
    , Put (0, 20)       (Makebox (50,10) l)
    , Put (0, 10)       (Makebox (50,10) n)
    , Put (0, 0)        (Makebox (50,10) m)]

mkCmpl :: String -> String -> String -> String -> [Command]
mkCmpl m l1 l2 n =
    [ Put (50, 0)       (Line (0,1) 20)
    , Put (50, 20)      (Line (-1,0) 50)
    , Put (0, 20)       (Line (0,1) 10)
    , Put (0, 30)       (Line (1,0) 150)
    , Put (150, 30)     (Line (0,-1) 10)
    , Put (150, 20)     (Line (-1,0) 50)
    , Put (100, 20)     (Line (0,-1) 20)
    , Put (100, 0)      (Line (-1,0) 50)
    , Put (0, 20)       (Makebox (50,10) l1)
    , Put (50, 20)      (Makebox (50,10) "$\\longrightarrow$")
    , Put (100, 20)     (Makebox (50,10) l2)
    , Put (50, 10)      (Makebox (50,10) n)
    , Put (50, 0)       (Makebox (50,10) m)]

render :: Diag -> Picture
render d = Picture (vec2Tup $ size_Syn_Diag run) (pict_Syn_Diag run)
    where run = wrap_Diag (sem_Diag d) inh
          inh = Inh_Diag
          vec2Tup (x:.y:.()) = (x,y)
}
