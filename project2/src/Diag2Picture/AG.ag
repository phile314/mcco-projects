-- | Attribute grammar for type checking t-diagrams

module {Diag2Picture.AG}{}{
import CCO.Diag (Diag(..), Diag_(..))
import CCO.Picture
import Debug.Trace
}

{
type Vec2 = (Double, Double)
type Size = Vec2
}

include "../CCO/Diag/AG.ag"

-- | Makes available the position in order for error messages.
attr Diag_ inh pos :: {SourcePos}
attr Diag syn pos :: {SourcePos}

sem Diag
  | Diag d.pos = @pos
         lhs.pos = @pos

-- | The type of a t-diagram.
-- The type returned is correct only if no error massage is raised.
attr Diag_ Diag
  syn pict :: {[Command]}
  syn size :: {Size}
  -- First element is x offset of left lower connection point, second element is distance from left to right connection point.
  syn conn :: {Vec2}

  -- tree transformation attributes
  syn ndiag :: self
  chn nlng :: String
  syn nchld :: self

-- Add right hand side element of Compile element (becomes CompileI)
sem Diag_
  | Program  lhs.nchld = Program @p @lhs.nlng
  | Interpreter lhs.nchld = Interpreter @i @l @lhs.nlng
  | Compiler lhs.nchld = Compiler @c @l1 @l2 @lhs.nlng
  | Compiler lhs.nlng = @l2
  | Compile  d1.nlng   = @d2.nlng 
             lhs.ndiag = (CompileI @d1.ndiag @d2.ndiag @d1.nchld)
  

sem Diag_
  | Program   (lhs.size, lhs.conn, lhs.pict)    = mkProg @l @p
  | Platform (lhs.size, lhs.conn, lhs.pict)    = mkPlat @m
  | Interpreter (lhs.size, lhs.conn, lhs.pict) = mkIntp @m @l @i
  | Compiler (lhs.size, lhs.conn, lhs.pict)    = mkCmpl @m @l1 @l2 @c
  | Execute  (lhs.size, lhs.conn, lhs.pict)    = mkExec @d1.pict @d1.conn @d1.size @d2.pict @d2.conn @d2.size
  | CompileI  (lhs.size, lhs.conn, lhs.pict)    = mkCmple @d1.pict @d1.conn @d1.size @d2.pict @d2.conn @d2.size @d3.pict @d3.conn @d3.size

{           


translate :: Vec2 -> [Command] -> [Command]
translate (dx, dy) cs = map f cs
  where f (Put (x, y) a) = Put (x + dx, y + dy) a
translate' d (a, cs) = (a, translate d cs)

-- for the time being, we assume that d1 is either a Program, Interpreter or Compiler
--mkCmple :: [Command] -> Vec2 -> Size -> [Command] -> Vec2 -> Size -> (Size, Vec2, [Command])
mkCmple p1 (ca1, cb1) (x1, y1) p2 (ca2, cb2) (x2, y2) p3 (cc1, cc2) (x3, y3) =
    (ns, (ca1 + cb1 + ca2, cb2),
    (translate (0, y2 - ovlp) p1) ++ (translate (ca1 + cb1, 0) p2) ++ (translate (ca1 + cb1 + x2 - cc1, y2 - ovlp) p3))
    where ovlp = 10
          ns = (ca1 + cb1 + x2 + (x3 - cc1), y2 + (max y1 y3) - ovlp)
          

mkExec :: [Command] -> Vec2 -> Size -> [Command] -> Vec2 -> Size -> (Size, Vec2, [Command])
mkExec p1 (ca1, cb1) (x1, y1) p2 (ca2, cb2) (x2, y2) = 
    ((max x1 x2, y1 + y2), (ca1 - ca2, cb2),
    (translate (0, y2) p1) ++ (translate (ca1, 0) p2))

mkProg :: String -> String -> (Size, Vec2, [Command])
mkProg l n = ((65, 30), (7.5, 50),
    [ Put (7.5, 0)      (Line (1,0)  50)
    , Put (7.5, 0)      (Line (0,1)  15)
    , Put (7.5, 15)     (Line (-1,2) 7.5)
    , Put (57.5, 15)    (Line (1,2)  7.5)
    , Put (57.5, 0)     (Line (0,1)  15)
    , Put (0, 30)       (Line (1,0)  65)
    , Put (7.5, 15)     (Makebox (50, 15) n)
    , Put (7.5, 0)      (Makebox (50, 15) l)])

mkPlat :: String -> (Size, Vec2, [Command])
mkPlat l = ((50, 30), (0, 0),
    [ Put (0, 15)       (Line (5,-3)  25)
    , Put (25, 0)       (Line (5,3)   25)
    , Put (0, 15)       (Line (0,1)   15)
    , Put (0, 30)       (Line (1,0)   50)
    , Put (50, 30)      (Line (0,-1)  15)
    , Put (0,15)        (Makebox (50,15) l)])

mkIntp :: String -> String -> String ->(Size, Vec2, [Command])
mkIntp m l n = ((50, 30), (0, 30),
    [ Put (0, 0)        (Framebox (50,30) "")
    , Put (0, 20)       (Makebox (50,10) l)
    , Put (0, 10)       (Makebox (50,10) n)
    , Put (0, 0)        (Makebox (50,10) m)])

mkCmpl :: String -> String -> String -> String -> (Size, Vec2, [Command])
mkCmpl m l1 l2 n = ((150, 30), (50, 50),
    [ Put (50, 0)       (Line (0,1) 20)
    , Put (50, 20)      (Line (-1,0) 50)
    , Put (0, 20)       (Line (0,1) 10)
    , Put (0, 30)       (Line (1,0) 150)
    , Put (150, 30)     (Line (0,-1) 10)
    , Put (150, 20)     (Line (-1,0) 50)
    , Put (100, 20)     (Line (0,-1) 20)
    , Put (100, 0)      (Line (-1,0) 50)
    , Put (0, 20)       (Makebox (50,10) l1)
    , Put (50, 20)      (Makebox (50,10) "$\\longrightarrow$")
    , Put (100, 20)     (Makebox (50,10) l2)
    , Put (50, 10)      (Makebox (50,10) n)
    , Put (50, 0)       (Makebox (50,10) m)])

foldTree :: Diag -> Picture
foldTree d = let fstRun = ndiag_Syn_Diag $ wrap_Diag (sem_Diag d) inh
                 sndRun = wrap_Diag (sem_Diag fstRun) inh
             in Picture (size_Syn_Diag sndRun) (pict_Syn_Diag sndRun)
    where inh = Inh_Diag undefined
}
