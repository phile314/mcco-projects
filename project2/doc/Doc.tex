\documentclass[12pt, a4paper, twoside]{article}
\usepackage{hyperref}
\usepackage{fullpage}
\usepackage{bussproofs}
\usepackage{color}
% font size could be 10pt (default), 11pt or 12 pt
% paper size coulde be letterpaper (default), legalpaper, executivepaper,
% a4paper, a5paper or b5paper
% side coulde be oneside (default) or twoside 
% columns coulde be onecolumn (default) or twocolumn
% graphics coulde be final (default) or draft 
%
% titlepage coulde be notitlepage (default) or titlepage which 
% makes an extra page for title 
% 
% paper alignment coulde be portrait (default) or landscape 
%
% equations coulde be 
%   default number of the equation on the rigth and equation centered 
%   leqno number on the left and equation centered 
%   fleqn number on the rigth and  equation on the left side
%   
\title{MMCO Project B}
\author{Marco Vassena  \\
    4110161 \\
    \and
    Philipp Hausmann \\
    4003373 \\
    }

\date{\today}

\newcommand{\sproof}{
  \scriptsize
  \begin{center}
  \begin{prooftree}
  \def\defaultHypSeparation{\hskip .1in}
% whats that doing? ->  \def\fCenter{\models}
}

\newcommand{\eproof}{
  \end{prooftree}
  \end{center}
  \normalsize
}

\newcommand{\bcase}[2]{
  \sproof
  \RightLabel{#2}
  \AxiomC{}
  \UnaryInfC{#1}
  \eproof
}

\newcommand{\blue}[1]{\textcolor{blue}{#1} }
\newcommand{\red}[1]{\textcolor{red}{#1}}

\begin{document}
\maketitle

\section{Formal Specification}
\label{sec:Spec}
This section formally specifies the type rules used for type-checking a t-diagram.
A t-diagram is considered well-typed, if there is a top-level type which can be derived
using the following rules, ill-typed otherwise.
In the following rules \blue{blue} encodes \blue{values} 
(\texttt{Diag\_} as defined in module \texttt{CCO.Diag}) 
and \red{red} encodes t-diagrams \red{types}.

% red for types, blue for constructors

\subsection{Basic values}
\bcase{\blue{Program \_ $l$} : \red{Program $l$ $()$}}{[program]}
\bcase{\blue{Platform $l_m$} : \red{Platform $l_m$}}{[platform]}
\bcase{\blue{Interpreter \_ $l_i$ $l_m$} : \red{Program $l_m$ (Platform $l_i$)}}{[interpreter]}
\bcase{\blue{Compiler \_ $l_1$ $l_2$ $l_m$} : \red{Program $l_m$ (Compiler $l_i$ $l_o$)}}{[compiler]}

\subsection{Compositional Cases}
\sproof
\RightLabel{[execute-on-platform]}
\AxiomC{\blue{d1} : \red{Program $l$ $r$}}
\AxiomC{\blue{d2} : \red{Platform $l$}}
\BinaryInfC{\blue{Execute d1 d2} : \red{$r$}}
\eproof

\sproof
\RightLabel{[execute-on-interpreter]}
\AxiomC{\blue{d1} : \red{Program $l_i$ $r$}}
\AxiomC{\blue{d1} : \red{Program $l_m$ (Platform $l_i$)}}
\BinaryInfC{\blue{Execute d1 d2} : \red{Program $l_m$ $r$}}
\eproof

\sproof
\RightLabel{[compile]}
\AxiomC{\blue{d1} : \red{Program $l_1$ $r$}}
\AxiomC{\blue{d2} : \red{Program $l_m$ (Compiler $l_1$ $l_2$)}}
\BinaryInfC{\blue{Compile d1 d2} : \red{Program $l_2$ $r$}}
\eproof

\section{Type Checking}
This section explains the design and the implementation of the program \texttt{tc-tdiag}, which 
enforces the type rules formally introduced in \ref{sec:Spec}.
The entry point of the program is \texttt{src/TcTDiag.hs} and does not require any particular
explanation.
The modules concerned with type-checking are contained in \texttt{Type} module:
\begin{itemize}
  \item \texttt{Type.AG}
  \item \texttt{Type.Internal}
  \item \texttt{Type.Error}
\end{itemize}
The module \texttt{Type.AG} contains the attribute grammar that actually type-checks the input 
and produces error messages.
The module \texttt{Type.Internal} defines the data type \texttt{Type}, that encodes t-diagram types.
The implementation replicates exactly the specification introduced in \ref{sec:Spec}.
The module \texttt{Type.Error} contains further sub-modules for producing specific errors 
(\texttt{Type.Error.EType} for type errors and \texttt{Type.Error.EScope} for scoping errors).
Particular effort has been put in making error messages as readable and informative as possible,
taking care of hiding the internal representation of types and producing precise source
position references.

\subsection{Attribute Grammar}
In the attribute grammar file (\texttt{src/Type/AG.ag}) the abstract syntax tree containing
\texttt{Diag} and \texttt{Diag\_} is inspected and typed.
The type rules defined in \ref{sec:Spec} have been extended in order to smartly raise type-error
only when needed. For this purpose an ad-hoc type \texttt{ErrorT} has been added to the set
 of supported types. This type is produced when a t-diagram is not well-typed and when
a t-diagrams is composed with an ill-typed t-diagram.
Using this type avoids generating superflous type-error messages, but it still allows to collect
as many non-trivial error messages as possible.
The following rules formally specifies how this type is generated:

\sproof
\RightLabel{[ErrorT-base]}
\AxiomC{\blue{d} is ill-typed}
\UnaryInfC{\blue{d} : \red{ErrorT}}
\eproof

\sproof
\RightLabel{[ErrorT-compile]}
\AxiomC{\blue{d1} : \red{ErrorT} $\lor$  \blue{d2} : \red{ErrorT}}
\UnaryInfC{\blue{Compile d1 d2} : \red{ErrorT}}
\eproof

\sproof
\RightLabel{[ErrorT-execute]}
\AxiomC{\blue{d1} : \red{ErrorT} $\lor$  \blue{d2} : \red{ErrorT}}
\UnaryInfC{\blue{Execute d1 d2} : \red{ErrorT}}
\eproof
The attributes of the attribute grammar are:
\begin{itemize}
  \item \texttt{pos}
  \item \texttt{ty}
  \item \texttt{msgs}
\end{itemize}
The attribute \texttt{pos} is a \texttt{SourcePos} object simply passed around and used inside
error messages.
The attribute \texttt{ty} is the \texttt{Type} of a \texttt{Diag}.
The attribute \texttt{msgs} is a list collecting the error messages generated.

\end{document}
